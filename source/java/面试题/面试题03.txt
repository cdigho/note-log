1、mysql如何解决幻读、脏读、不可重复读?
可重复读隔离级别下mysql会自动触发间隙锁和临键锁解决幻读;mysql通过S、X锁机制解决脏读;mysql通过MVCC机制解决不可重复读。
2、如何保证MQ消息不丢失,如何实现延时推送等
发送方确认发送结果;broker同步或异步刷盘持久化;接收方发送接收结果。
3、如何实现缓存一致性
简单实用的延时双删策略
4、如何解决大表查询
在主键id为自增的前提下,可使用子查询代替limit
5、Stream的用法
map()flatMap()distinct()等
6、or和in是否会用到索引
or的左右两边都是索引就才会走索引;in当待查询的值集合数量远小于表的总行数时才会走索引,否则也会全表扫描
7、数据加密方式
MD5 RSA2
8、synchronized的可重入怎么实现
底层都用CAS实现
9、jvm类加载到执行内存变化过程,垃圾回收从哪寻根回收的,GCRoot都有哪些内容
JDK1.8:元空间->堆->栈帧;
虚拟机栈(栈帧中的本地变量表)中引用的对象;
方法区中类静态属性引用的对象;
方法区中常量引用的对象;
本地方法栈中 JNI引用的对象
10、synchronized静态方法和普通方法锁的对象是什么
静态方法锁Class对象;普通方法锁new出来的对象
11、Java对象的锁结构放在什么地方
放在堆内对象的头部
18、rocketMQ和Kafka的区别
rocketMQ可实现事务、延时消息;KafkaTPS较大,一般用作日志处理
19、jackson和fastjson的原理和区别,及Serializable的原理
fastjson比较快bug多;jackson用在框架比较多,注解丰富。
20、线程池参数设计会根据什么因素考量,多线程应用场景(用户登录发权益)
QPS、单个任务执行时间、请求可等待最大时长。
21、线程之间的通信如何实现
通过锁机制
22、雪花算法
用于生成分布式id。由时间戳+机器ld+服务
ld+序列号组成
23、transactionTemplate和@Transaction的区别
编程式事务可控制较小粒度的代码;声明式事务统一管理更方便。
24、一个consumer订阅多个topic,其中一个topic积压会影响consumer的性能吗
不会。
25、阻塞队列和非阻塞队列
阻塞队列通过ReentrantLock实现;
26、Jedis和Lettuce的区别
Lettuce基于netty实现,吞吐量优于Jedis
27、TCP和HTTP的区别
http是无状态的短连接,tcp是有状态的长连接
28、过滤器和拦截器的区别
过滤器是servlet层面的,拦截器是spring的
29、鉴权方式
token/JWT
30、equals
Integer a=1; int b=1;
a.equals(b)=true是拆箱操作
32、商品库存管理如何防止超卖
使用redis并自己写lua脚本实现
33、注解的实现原理
动态代理实现
34、多线程事物回滚
利用CountDownLatch
35、web socket
会使用就行
36、异常处理机制
顶级父类Throwable,两个子类Error和Exception,Error不可捕获
37、类加载机制,怎们能破坏这个机制
双亲委派机制;继承ClassLoader重写loadClass()方法。
